"use client";

import { endOfMonth, parseISO, startOfMonth } from "date-fns";
import { useMemo, useState } from "react";

import { COLOR_PALETTE } from "@/lib/mocks/calendar";
import { toDateKey } from "@/lib/calendar/utils";
import { useCalendarState } from "./hooks/useCalendarState";
import type { CalendarEvent, EventDraft, ViewMode, CalendarSource } from "@/types/calendar";
import { CalendarHeader } from "./components/CalendarHeader";
import { CalendarMonthView } from "./components/CalendarMonthView";
import { CalendarTimelineView } from "./components/CalendarTimelineView";
import { AgendaView } from "./components/AgendaView";
import { CalendarDetailsPanel } from "./components/CalendarDetailsPanel";
import { CalendarCreateModal } from "./components/CalendarCreateModal";
import { CalendarManageModal } from "./components/CalendarManageModal";
import Drawer from "@/components/ui/Drawer";

const MAX_VISIBLE_EVENTS_PER_DAY = 2;

export default function CalendarView({
  initialDate = new Date(),
  initialView = "month",
}: {
  initialDate?: Date;
  initialView?: ViewMode;
}) {
  const {
    current,
    selectedDate,
    setSelectedDate,
    view,
    setView,
    calendars,
    searchTerm,
    setSearchTerm,
    isFormOpen,
    formError,
    setFormError,
    draft,
    setDraft,
    editingEventId,
    showCalendarForm,
    setShowCalendarForm,
    newCalendarName,
    setNewCalendarName,
    newCalendarColor,
    setNewCalendarColor,
    calendarMap,
    filteredEvents,
    eventsByDate,
    monthDays,
    goPrev,
    goNext,
    goToday,
    handleToggleCalendar,
    handleAddCalendar,
    handleUpdateCalendar,
    handleDeleteCalendar,
    openForm,
    openEditForm,
    handleSubmitEvent,
    handleDeleteEvent,
    closeForm,
  } = useCalendarState(initialDate, initialView);

  const [detailsOpen, setDetailsOpen] = useState(false);
  const [manageOpen, setManageOpen] = useState(false);
  const [manageCalendarId, setManageCalendarId] = useState<string | null>(null);
  const [manageName, setManageName] = useState("");
  const [manageColor, setManageColor] = useState("#0c66e4");
  const [manageError, setManageError] = useState<string | null>(null);

  const monthStart = useMemo(() => startOfMonth(current), [current]);
  const monthEnd = useMemo(() => endOfMonth(current), [current]);

  const agendaEvents = useMemo(
    () =>
      filteredEvents.filter((event) => {
        const start = parseISO(event.start);
        const end = event.end ? parseISO(event.end) : start;
        return end >= monthStart && start <= monthEnd;
      }),
    [filteredEvents, monthStart, monthEnd],
  );

  const selectedKey = toDateKey(selectedDate);
  const selectedEvents = eventsByDate.get(selectedKey) ?? [];

  const handleChangeDraft = (patch: Partial<EventDraft>) => {
    setDraft((prev) => {
      const next = { ...prev, ...patch };
      if (patch.startDate && next.endDate < patch.startDate) {
        next.endDate = patch.startDate;
      }
      if (patch.endDate && patch.endDate < next.startDate) {
        next.endDate = next.startDate;
      }
      if (patch.allDay === true) {
        next.startTime = "";
        next.endTime = "";
      }
      if (patch.allDay === false) {
        next.startTime = next.startTime || "09:00";
        next.endTime = next.endTime || "10:00";
      }
      return next;
    });
    setFormError(null);
  };

  const handleRequestNewCalendar = () => {
    if (!showCalendarForm) {
      const nextColor =
        COLOR_PALETTE[calendars.length % COLOR_PALETTE.length] ?? COLOR_PALETTE[0] ?? "#0c66e4";
      setNewCalendarColor(nextColor);
      setNewCalendarName("");
    }
    setShowCalendarForm(true);
  };

  const handleCancelNewCalendar = () => {
    setShowCalendarForm(false);
    setNewCalendarName("");
    setNewCalendarColor(COLOR_PALETTE[0] ?? "#0c66e4");
  };

  const handleSelectDate = (date: Date) => {
    setSelectedDate(date);
    if (isFormOpen) {
      const key = toDateKey(date);
      setDraft((prev) => {
        const adjustedEnd = prev.endDate < key ? key : prev.endDate;
        return { ...prev, startDate: key, endDate: adjustedEnd };
      });
    }
  };

  const handleRequestDetails = (date?: Date) => {
    if (date) {
      setSelectedDate(date);
    }
    setDetailsOpen(true);
  };

  const handleOpenForm = (date: Date) => {
    setDetailsOpen(true);
    openForm(date);
  };

  const handleEditEvent = (event: CalendarEvent) => {
    setDetailsOpen(true);
    openEditForm(event);
  };

  const handleCloseForm = () => {
    closeForm();
  };

  const handleCloseDetails = () => {
    setDetailsOpen(false);
    closeForm();
  };

  const handleOpenManageCalendar = (calendar: CalendarSource) => {
    setManageCalendarId(calendar.id);
    setManageName(calendar.name);
    setManageColor(calendar.color);
    setManageError(null);
    setManageOpen(true);
  };

  const handleSubmitManageCalendar = () => {
    if (!manageCalendarId) return;
    const nextName = manageName.trim();
    if (!nextName) {
      setManageError("이름을 입력해주세요.");
      return;
    }
    handleUpdateCalendar(manageCalendarId, { name: nextName, color: manageColor });
    setManageOpen(false);
  };

  const handleDeleteManageCalendar = () => {
    if (!manageCalendarId) return;
    handleDeleteCalendar(manageCalendarId);
    setManageOpen(false);
  };

  return (
    <div className="flex min-h-0 flex-1 flex-col bg-background">
      <CalendarHeader
        current={current}
        view={view}
        searchTerm={searchTerm}
        calendars={calendars}
        calendarMap={calendarMap}
        onSearch={setSearchTerm}
        onPrev={goPrev}
        onNext={goNext}
