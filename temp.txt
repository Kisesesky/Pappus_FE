'use client';

import { useCallback, useEffect, useMemo, useState } from 'react';
import type { ElementType } from 'react';
import { useRouter } from 'next/navigation';
import { CalendarClock, Clock3, LayoutGrid, List as ListIcon, Star, Upload, Users } from 'lucide-react';

import {
  DOC_FOLDER_EVENT,
  DocFolder,
  DocMeta,
  addDocMeta,
  assignDocToFolder,
  createDocFolder,
  deleteDocFolder,
  generateDocId,
  nextUntitledName,
  persistDocCollection,
  readDocCollection,
  readDocFolders,
  removeDocMeta,
  updateDocFolder,
  updateDocMeta,
} from '@/lib/docs';
import { DocumentGrid } from '@/components/docs/note-drive/DocumentGrid';
import { DocumentTable, type SortKey } from '@/components/docs/note-drive/DocumentTable';
import { FolderGrid } from '@/components/docs/note-drive/FolderGrid';
import { FilterMenu } from '@/components/docs/note-drive/FilterMenu';
import { SortMenu } from '@/components/docs/note-drive/SortMenu';
import { CreateFolderModal } from '@/components/docs/note-drive/CreateFolderModal';
import { formatFileSize, relativeTime } from '@/components/docs/note-drive/utils';

type FilterKey = 'all' | 'starred' | 'shared' | 'recent';

const FILTERS: { key: FilterKey; label: string; icon: ElementType; hint: string }[] = [
  { key: 'all', label: 'ì „ì²´ ë¬¸ì„œ', icon: LayoutGrid, hint: 'ëª¨ë“  ë¬¸ì„œ' },
  { key: 'starred', label: 'ì¤‘ìš”', icon: Star, hint: 'ì¦ê²¨ì°¾ê¸° ë¬¸ì„œ' },
  { key: 'shared', label: 'ê³µìœ ë¨', icon: Users, hint: 'ê³µìœ  ë¬¸ì„œ' },
  { key: 'recent', label: 'ìµœê·¼ ìˆ˜ì •', icon: Clock3, hint: '24ì‹œê°„ ì´ë‚´ ìˆ˜ì •' },
];

const FILTER_CHIPS = [
  { id: 'type', label: 'ìœ í˜•' },
  { id: 'person', label: 'ì‚¬ëŒ' },
  { id: 'modified', label: 'ìˆ˜ì • ë‚ ì§œ' },
  { id: 'source', label: 'ì¶œì²˜' },
] as const;

const CHIP_OPTIONS: Record<(typeof FILTER_CHIPS)[number]['id'], { value: string; label: string }[]> = {
  type: [
    { value: 'all', label: 'ëª¨ë“  ìœ í˜•' },
    { value: 'doc', label: 'ë…¸íŠ¸' },
    { value: 'template', label: 'í…œí”Œë¦¿' },
  ],
  person: [
    { value: 'all', label: 'ëª¨ë“  ì‚¬ëŒ' },
    { value: 'mine', label: 'ë‚´ê°€ ì†Œìœ ' },
    { value: 'shared', label: 'ê³µìœ ë¨' },
  ],
  modified: [
    { value: 'anytime', label: 'ì „ì²´ ê¸°ê°„' },
    { value: '7days', label: 'ì§€ë‚œ 7ì¼' },
    { value: '30days', label: 'ì§€ë‚œ 30ì¼' },
  ],
  source: [
    { value: 'all', label: 'ëª¨ë“  ì¶œì²˜' },
    { value: 'workspace', label: 'ì›Œí¬ìŠ¤í˜ì´ìŠ¤' },
    { value: 'imported', label: 'ê°€ì ¸ì˜¨ ë¬¸ì„œ' },
  ],
};

export default function DocsDashboard() {
  const router = useRouter();
  const [docs, setDocs] = useState<DocMeta[]>(() => readDocCollection());
  const [folders, setFolders] = useState<DocFolder[]>(() => readDocFolders());
  const [activeFolder, setActiveFolder] = useState<'all' | 'unfiled' | string>('all');
  const [filter, setFilter] = useState<FilterKey>('all');
  const [query, setQuery] = useState('');
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('list');
  const [sortKey, setSortKey] = useState<SortKey>('title');
  const [sortDir, setSortDir] = useState<'asc' | 'desc'>('asc');
  const [chipSelections, setChipSelections] = useState<Record<string, string>>({
    type: CHIP_OPTIONS.type[0].value,
    person: CHIP_OPTIONS.person[0].value,
    modified: CHIP_OPTIONS.modified[0].value,
    source: CHIP_OPTIONS.source[0].value,
  });
  const [folderModalOpen, setFolderModalOpen] = useState(false);

  useEffect(() => {
    const syncDocs = () => setDocs(readDocCollection());
    const handler = () => syncDocs();
    window.addEventListener('docs:meta-updated', handler);
    syncDocs();
    return () => window.removeEventListener('docs:meta-updated', handler);
  }, []);

  useEffect(() => {
    const syncFolders = () => setFolders(readDocFolders());
    const handler = () => syncFolders();
    window.addEventListener(DOC_FOLDER_EVENT, handler as EventListener);
    syncFolders();
    return () => window.removeEventListener(DOC_FOLDER_EVENT, handler as EventListener);
  }, []);

  useEffect(() => {
    if (activeFolder === 'all' || activeFolder === 'unfiled') return;
    if (!folders.some((folder) => folder.id === activeFolder)) {
      setActiveFolder('all');
    }
  }, [folders, activeFolder]);

  const folderMap = useMemo(() => {
    const map = new Map<string, DocFolder>();
    folders.forEach((folder) => map.set(folder.id, folder));
    return map;
  }, [folders]);

  const docCountsByFolder = useMemo(() => {
    const counts = new Map<string, number>();
    docs.forEach((doc) => {
      const folderId = resolveFolderId(doc, folders);
      const key = folderId ?? 'unfiled';
      counts.set(key, (counts.get(key) ?? 0) + 1);
    });
    return counts;
  }, [docs, folders]);

  const breadcrumbs = useMemo(() => {
    const trail = ['ë‚´ ë“œë¼ì´ë¸Œ'];
    if (activeFolder === 'unfiled') {
      trail.push('ë¯¸ë¶„ë¥˜ ë…¸íŠ¸');
    } else if (activeFolder !== 'all') {
      const target = folderMap.get(activeFolder);
      if (target) trail.push(target.name);
    }
    return trail;
  }, [activeFolder, folderMap]);

  const applyCollection = useCallback((updater: (list: DocMeta[]) => DocMeta[]) => {
    setDocs((prev) => {
      const next = updater(prev);
      persistDocCollection(next);
      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('docs:meta-updated', { detail: { action: 'update' } }));
      }
      return next;
    });
  }, []);

  const handleCreateDoc = () => {
    const id = generateDocId();
    const title = nextUntitledName(docs);
    const currentFolder =
      activeFolder !== 'all' && activeFolder !== 'unfiled' ? folderMap.get(activeFolder) : undefined;
    const doc: DocMeta = {
      id,
      title,
      owner: 'ë‚˜',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      description: 'ìƒˆ Flowdash ë…¸íŠ¸',
      color: pickColor(docs.length),
      icon: 'ğŸ“„',
      sharedWith: 0,
      folderId: currentFolder?.id,
      location: currentFolder ? `${currentFolder.name} / ${title}` : `ë‚´ ë“œë¼ì´ë¸Œ / ${title}`,
      fileSize: 120,
    };
    const created = addDocMeta(doc);
    setDocs((prev) => [created, ...prev.filter((item) => item.id !== created.id)]);
    router.push(`/docs/${created.id}`);
  };

  const handleDuplicate = (doc: DocMeta) => {
    const duplicated: DocMeta = {
      ...doc,
      id: generateDocId(),
      title: `${doc.title} ë³µì œë³¸`,
      starred: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      lastOpenedAt: undefined,
    };
    const created = addDocMeta(duplicated);
    setDocs((prev) => [created, ...prev]);
  };

  const handleRename = (doc: DocMeta) => {
    const name = window.prompt('ë¬¸ì„œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”', doc.title);

